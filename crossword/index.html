<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crossword Builder</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        function CrosswordBuilder() {
          const [gridSize, setGridSize] = useState({ rows: 10, cols: 10 });
          const [grid, setGrid] = useState(() => 
            Array(10).fill(null).map(() => 
              Array(10).fill(null).map(() => ({ letter: '', isBlack: false, number: null }))
            )
          );
          const [clues, setClues] = useState({ across: {}, down: {} });
          const [selectedCell, setSelectedCell] = useState(null);
          const [direction, setDirection] = useState('across'); // 'across' or 'down'
          const [draggedLetter, setDraggedLetter] = useState(null);
          const [showClueEditor, setShowClueEditor] = useState(false);
          const [showWordFinder, setShowWordFinder] = useState(false);
          const [wordPattern, setWordPattern] = useState('');
          const [foundWords, setFoundWords] = useState([]);
          const [isSearching, setIsSearching] = useState(false);
          const [showExportModal, setShowExportModal] = useState(false);
          const [exportedData, setExportedData] = useState('');
          const [importData, setImportData] = useState('');

          const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');

          // Auto-focus selected cell
          useEffect(() => {
            if (selectedCell) {
              const cellElement = document.querySelector(`[data-cell="${selectedCell.row}-${selectedCell.col}"]`);
              if (cellElement) {
                cellElement.focus();
              }
            }
          }, [selectedCell]);

          const updateCell = (row, col, updates) => {
            setGrid(prev => {
              const newGrid = prev.map(r => r.map(c => ({ ...c })));
              newGrid[row][col] = { ...newGrid[row][col], ...updates };
              return newGrid;
            });
          };

          const handleCellClick = (row, col) => {
            if (selectedCell?.row === row && selectedCell?.col === col) {
              // Toggle direction if clicking the same cell
              setDirection(prev => prev === 'across' ? 'down' : 'across');
            } else {
              // New cell selected, default to across
              setSelectedCell({ row, col });
              setDirection('across');
            }
          };

          const handleCellKeyDown = (e, row, col) => {
            if (e.key === ' ') {
              e.preventDefault();
              updateCell(row, col, { isBlack: !grid[row][col].isBlack, letter: '' });
            } else if (e.key.length === 1 && /[a-zA-Z]/.test(e.key)) {
              e.preventDefault();
              updateCell(row, col, { letter: e.key.toUpperCase(), isBlack: false });
              // Move to next cell in current direction
              moveToNextCell(row, col, direction);
            } else if (e.key === 'Backspace' || e.key === 'Delete') {
              e.preventDefault();
              if (grid[row][col].letter) {
                // If there's a letter, just delete it
                updateCell(row, col, { letter: '' });
              } else {
                // If cell is empty, delete and move to previous cell
                moveToPreviousCell(row, col, direction);
              }
            } else if (e.key === 'ArrowRight') {
              e.preventDefault();
              if (col < gridSize.cols - 1) {
                setSelectedCell({ row, col: col + 1 });
                setDirection('across');
              }
            } else if (e.key === 'ArrowLeft') {
              e.preventDefault();
              if (col > 0) {
                setSelectedCell({ row, col: col - 1 });
                setDirection('across');
              }
            } else if (e.key === 'ArrowDown') {
              e.preventDefault();
              if (row < gridSize.rows - 1) {
                setSelectedCell({ row: row + 1, col });
                setDirection('down');
              }
            } else if (e.key === 'ArrowUp') {
              e.preventDefault();
              if (row > 0) {
                setSelectedCell({ row: row - 1, col });
                setDirection('down');
              }
            } else if (e.key === 'Tab') {
              e.preventDefault();
              // Tab moves to next cell in current direction
              moveToNextCell(row, col, direction);
            }
          };

          const moveToNextCell = (row, col, dir) => {
            if (dir === 'across') {
              // Move right, skip black cells
              let nextCol = col + 1;
              while (nextCol < gridSize.cols && grid[row][nextCol].isBlack) {
                nextCol++;
              }
              if (nextCol < gridSize.cols) {
                setSelectedCell({ row, col: nextCol });
              } else {
                // Wrap to next row
                let nextRow = row + 1;
                if (nextRow < gridSize.rows) {
                  let newCol = 0;
                  while (newCol < gridSize.cols && grid[nextRow][newCol].isBlack) {
                    newCol++;
                  }
                  if (newCol < gridSize.cols) {
                    setSelectedCell({ row: nextRow, col: newCol });
                  }
                }
              }
            } else {
              // Move down, skip black cells
              let nextRow = row + 1;
              while (nextRow < gridSize.rows && grid[nextRow][col].isBlack) {
                nextRow++;
              }
              if (nextRow < gridSize.rows) {
                setSelectedCell({ row: nextRow, col });
              } else {
                // Wrap to next column
                let nextCol = col + 1;
                if (nextCol < gridSize.cols) {
                  let newRow = 0;
                  while (newRow < gridSize.rows && grid[newRow][nextCol].isBlack) {
                    newRow++;
                  }
                  if (newRow < gridSize.rows) {
                    setSelectedCell({ row: newRow, col: nextCol });
                  }
                }
              }
            }
          };

          const moveToPreviousCell = (row, col, dir) => {
            if (dir === 'across') {
              // Move left, skip black cells
              let prevCol = col - 1;
              while (prevCol >= 0 && grid[row][prevCol].isBlack) {
                prevCol--;
              }
              if (prevCol >= 0) {
                setSelectedCell({ row, col: prevCol });
                // Delete the letter in the previous cell
                updateCell(row, prevCol, { letter: '' });
              } else {
                // Wrap to previous row
                let prevRow = row - 1;
                if (prevRow >= 0) {
                  let newCol = gridSize.cols - 1;
                  while (newCol >= 0 && grid[prevRow][newCol].isBlack) {
                    newCol--;
                  }
                  if (newCol >= 0) {
                    setSelectedCell({ row: prevRow, col: newCol });
                    updateCell(prevRow, newCol, { letter: '' });
                  }
                }
              }
            } else {
              // Move up, skip black cells
              let prevRow = row - 1;
              while (prevRow >= 0 && grid[prevRow][col].isBlack) {
                prevRow--;
              }
              if (prevRow >= 0) {
                setSelectedCell({ row: prevRow, col });
                updateCell(prevRow, col, { letter: '' });
              } else {
                // Wrap to previous column
                let prevCol = col - 1;
                if (prevCol >= 0) {
                  let newRow = gridSize.rows - 1;
                  while (newRow >= 0 && grid[newRow][prevCol].isBlack) {
                    newRow--;
                  }
                  if (newRow >= 0) {
                    setSelectedCell({ row: newRow, col: prevCol });
                    updateCell(newRow, prevCol, { letter: '' });
                  }
                }
              }
            }
          };

          const handleDragStart = (letter) => {
            setDraggedLetter(letter);
          };

          const handleDragOver = (e) => {
            e.preventDefault();
          };

          const handleDrop = (e, row, col) => {
            e.preventDefault();
            if (draggedLetter) {
              updateCell(row, col, { letter: draggedLetter, isBlack: false });
              setDraggedLetter(null);
            }
          };

          const autoNumberGrid = () => {
            const newGrid = grid.map(r => r.map(c => ({ ...c, number: null })));
            let currentNumber = 1;

            for (let row = 0; row < gridSize.rows; row++) {
              for (let col = 0; col < gridSize.cols; col++) {
                if (newGrid[row][col].isBlack) continue;

                const startsAcross = (col === 0 || newGrid[row][col - 1].isBlack) && 
                                    col < gridSize.cols - 1 && 
                                    !newGrid[row][col + 1].isBlack;
                
                const startsDown = (row === 0 || newGrid[row - 1][col].isBlack) && 
                                  row < gridSize.rows - 1 && 
                                  !newGrid[row + 1][col].isBlack;

                if (startsAcross || startsDown) {
                  newGrid[row][col].number = currentNumber;
                  currentNumber++;
                }
              }
            }

            setGrid(newGrid);
          };

          const updateClue = (direction, number, text) => {
            setClues(prev => ({
              ...prev,
              [direction]: { ...prev[direction], [number]: text }
            }));
          };

          const getClueNumbers = () => {
            const numbers = { across: new Set(), down: new Set() };
            
            for (let row = 0; row < gridSize.rows; row++) {
              for (let col = 0; col < gridSize.cols; col++) {
                const cell = grid[row][col];
                if (cell.number) {
                  const startsAcross = (col === 0 || grid[row][col - 1].isBlack) && 
                                      col < gridSize.cols - 1 && 
                                      !grid[row][col + 1].isBlack;
                  const startsDown = (row === 0 || grid[row - 1][col].isBlack) && 
                                    row < gridSize.rows - 1 && 
                                    !grid[row + 1][col].isBlack;
                  
                  if (startsAcross) numbers.across.add(cell.number);
                  if (startsDown) numbers.down.add(cell.number);
                }
              }
            }
            
            return {
              across: Array.from(numbers.across).sort((a, b) => a - b),
              down: Array.from(numbers.down).sort((a, b) => a - b)
            };
          };

          const clueNumbers = getClueNumbers();

          const searchWords = async () => {
            if (!wordPattern || wordPattern.length < 2) {
              alert('Please enter a pattern (use ? for unknown letters, e.g., "C?T")');
              return;
            }

            setIsSearching(true);
            setFoundWords([]);

            try {
              const pattern = wordPattern.toUpperCase().replace(/\?/g, '.');
              const length = wordPattern.length;
              
              const response = await fetch(
                `https://api.datamuse.com/words?sp=${wordPattern.replace(/\?/g, '?')}&max=100`
              );
              
              const data = await response.json();
              const words = data
                .map(item => item.word.toUpperCase())
                .filter(word => word.length === length && /^[A-Z]+$/.test(word));
              
              setFoundWords(words);
            } catch (error) {
              console.error('Error searching words:', error);
              alert('Error searching for words. Please try again.');
            } finally {
              setIsSearching(false);
            }
          };

          const fillWordInGrid = (word) => {
            if (!selectedCell) {
              alert('Please select a cell in the grid first to place the word');
              return;
            }

            const { row, col } = selectedCell;
            
            if (col + word.length <= gridSize.cols) {
              let canFill = true;
              for (let i = 0; i < word.length; i++) {
                if (grid[row][col + i].isBlack) {
                  canFill = false;
                  break;
                }
              }
              
              if (canFill) {
                const newGrid = grid.map(r => r.map(c => ({ ...c })));
                for (let i = 0; i < word.length; i++) {
                  newGrid[row][col + i].letter = word[i];
                  newGrid[row][col + i].isBlack = false;
                }
                setGrid(newGrid);
                return;
              }
            }
            
            if (row + word.length <= gridSize.rows) {
              let canFill = true;
              for (let i = 0; i < word.length; i++) {
                if (grid[row + i][col].isBlack) {
                  canFill = false;
                  break;
                }
              }
              
              if (canFill) {
                const newGrid = grid.map(r => r.map(c => ({ ...c })));
                for (let i = 0; i < word.length; i++) {
                  newGrid[row + i][col].letter = word[i];
                  newGrid[row + i][col].isBlack = false;
                }
                setGrid(newGrid);
                return;
              }
            }
            
            alert('Cannot fit word at selected position. Make sure there is enough space and no black cells in the way.');
          };

          const getWordAtPosition = (row, col, direction) => {
            let pattern = '';
            
            if (direction === 'across') {
              let startCol = col;
              while (startCol > 0 && !grid[row][startCol - 1].isBlack) {
                startCol--;
              }
              
              let c = startCol;
              while (c < gridSize.cols && !grid[row][c].isBlack) {
                pattern += grid[row][c].letter || '?';
                c++;
              }
            } else {
              let startRow = row;
              while (startRow > 0 && !grid[startRow - 1][col].isBlack) {
                startRow--;
              }
              
              let r = startRow;
              while (r < gridSize.rows && !grid[r][col].isBlack) {
                pattern += grid[r][col].letter || '?';
                r++;
              }
            }
            
            return pattern;
          };

          const findWordForCurrentCell = (direction) => {
            if (!selectedCell) {
              alert('Please select a cell in the grid first');
              return;
            }
            
            const pattern = getWordAtPosition(selectedCell.row, selectedCell.col, direction);
            if (pattern.length < 2) {
              alert('Selected cell is not part of a valid word position');
              return;
            }
            
            setWordPattern(pattern);
            setShowWordFinder(true);
            setTimeout(() => {
              const searchButton = document.getElementById('word-search-button');
              if (searchButton) searchButton.click();
            }, 100);
          };

          const exportCrossword = () => {
            const crosswordData = {
              gridSize,
              grid,
              clues,
              version: '1.0'
            };
            const jsonString = JSON.stringify(crosswordData, null, 2);
            setExportedData(jsonString);
            setShowExportModal(true);
          };

          const downloadCrossword = () => {
            const blob = new Blob([exportedData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'crossword.json';
            a.click();
            URL.revokeObjectURL(url);
          };

          const copyToClipboard = () => {
            navigator.clipboard.writeText(exportedData).then(() => {
              alert('Copied to clipboard! Share this with others to let them solve your crossword.');
            });
          };

          const importCrossword = () => {
            try {
              const data = JSON.parse(importData);
              if (data.grid && data.gridSize && data.clues) {
                setGrid(data.grid);
                setGridSize(data.gridSize);
                setClues(data.clues);
                setImportData('');
                setShowExportModal(false);
                alert('Crossword imported successfully!');
              } else {
                alert('Invalid crossword data format');
              }
            } catch (error) {
              alert('Error importing crossword. Please check the data format.');
            }
          };

          const generateSharableHTML = () => {
            const solverGrid = grid.map(row => 
              row.map(cell => ({
                ...cell,
                letter: cell.isBlack ? '' : ''
              }))
            );

            const gridData = JSON.stringify(grid);
            const solverGridData = JSON.stringify(solverGrid);
            const gridSizeData = JSON.stringify(gridSize);
            const cluesData = JSON.stringify(clues);

            const htmlContent = '<!DOCTYPE html>\n' +
'<html lang="en">\n' +
'<head>\n' +
'    <meta charset="UTF-8">\n' +
'    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n' +
'    <title>Crossword Puzzle</title>\n' +
'    <script src="https://cdn.tailwindcss.com"><\/script>\n' +
'</head>\n' +
'<body class="bg-gradient-to-br from-purple-50 to-blue-50 min-h-screen p-8">\n' +
'    <div class="max-w-6xl mx-auto">\n' +
'        <h1 class="text-4xl font-bold text-gray-800 mb-8 text-center">Crossword Puzzle</h1>\n' +
'        \n' +
'        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">\n' +
'            <div class="mb-4 flex gap-2 flex-wrap">\n' +
'                <button onclick="checkAnswers()" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">\n' +
'                    Check Answers\n' +
'                </button>\n' +
'                <button onclick="revealAnswers()" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">\n' +
'                    Reveal Answers\n' +
'                </button>\n' +
'                <button onclick="clearGrid()" class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700">\n' +
'                    Clear Grid\n' +
'                </button>\n' +
'            </div>\n' +
'            \n' +
'            <div id="grid" class="inline-block border-4 border-gray-800 mb-6"></div>\n' +
'        </div>\n' +
'\n' +
'        <div class="bg-white rounded-lg shadow-lg p-6">\n' +
'            <h2 class="text-2xl font-bold text-gray-800 mb-4">Clues</h2>\n' +
'            <div class="grid md:grid-cols-2 gap-6">\n' +
'                <div>\n' +
'                    <h3 class="text-xl font-semibold text-gray-700 mb-3">Across</h3>\n' +
'                    <div id="across-clues" class="space-y-2"></div>\n' +
'                </div>\n' +
'                <div>\n' +
'                    <h3 class="text-xl font-semibold text-gray-700 mb-3">Down</h3>\n' +
'                    <div id="down-clues" class="space-y-2"></div>\n' +
'                </div>\n' +
'            </div>\n' +
'        </div>\n' +
'    </div>\n' +
'\n' +
'    <script>\n' +
'        const originalGrid = ' + gridData + ';\n' +
'        const gridSize = ' + gridSizeData + ';\n' +
'        const clues = ' + cluesData + ';\n' +
'        let currentGrid = ' + solverGridData + ';\n' +
'\n' +
'        function renderGrid() {\n' +
'            const gridDiv = document.getElementById("grid");\n' +
'            gridDiv.innerHTML = "";\n' +
'            \n' +
'            currentGrid.forEach((row, rowIndex) => {\n' +
'                const rowDiv = document.createElement("div");\n' +
'                rowDiv.className = "flex";\n' +
'                \n' +
'                row.forEach((cell, colIndex) => {\n' +
'                    const cellDiv = document.createElement("div");\n' +
'                    cellDiv.className = "w-12 h-12 border border-gray-400 relative " + \n' +
'                                       (cell.isBlack ? "bg-gray-900" : "bg-white");\n' +
'                    \n' +
'                    if (!cell.isBlack) {\n' +
'                        if (cell.number) {\n' +
'                            const numSpan = document.createElement("span");\n' +
'                            numSpan.className = "absolute top-0.5 left-0.5 text-xs font-bold text-gray-700";\n' +
'                            numSpan.textContent = cell.number;\n' +
'                            cellDiv.appendChild(numSpan);\n' +
'                        }\n' +
'                        \n' +
'                        const input = document.createElement("input");\n' +
'                        input.type = "text";\n' +
'                        input.maxLength = 1;\n' +
'                        input.value = cell.letter || "";\n' +
'                        input.className = "w-full h-full text-center text-2xl font-bold text-gray-800 uppercase border-0 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-inset";\n' +
'                        input.onkeydown = (e) => handleKeyDown(e, rowIndex, colIndex);\n' +
'                        input.oninput = (e) => {\n' +
'                            currentGrid[rowIndex][colIndex].letter = e.target.value.toUpperCase();\n' +
'                        };\n' +
'                        cellDiv.appendChild(input);\n' +
'                    }\n' +
'                    \n' +
'                    rowDiv.appendChild(cellDiv);\n' +
'                });\n' +
'                \n' +
'                gridDiv.appendChild(rowDiv);\n' +
'            });\n' +
'        }\n' +
'\n' +
'        function handleKeyDown(e, row, col) {\n' +
'            if (e.key === "ArrowRight" && col < gridSize.cols - 1) {\n' +
'                e.preventDefault();\n' +
'                focusCell(row, col + 1);\n' +
'            } else if (e.key === "ArrowLeft" && col > 0) {\n' +
'                e.preventDefault();\n' +
'                focusCell(row, col - 1);\n' +
'            } else if (e.key === "ArrowDown" && row < gridSize.rows - 1) {\n' +
'                e.preventDefault();\n' +
'                focusCell(row + 1, col);\n' +
'            } else if (e.key === "ArrowUp" && row > 0) {\n' +
'                e.preventDefault();\n' +
'                focusCell(row - 1, col);\n' +
'            }\n' +
'        }\n' +
'\n' +
'        function focusCell(row, col) {\n' +
'            const inputs = document.querySelectorAll("#grid input");\n' +
'            let index = 0;\n' +
'            for (let r = 0; r < gridSize.rows; r++) {\n' +
'                for (let c = 0; c < gridSize.cols; c++) {\n' +
'                    if (!currentGrid[r][c].isBlack) {\n' +
'                        if (r === row && c === col) {\n' +
'                            inputs[index].focus();\n' +
'                            return;\n' +
'                        }\n' +
'                        index++;\n' +
'                    }\n' +
'                }\n' +
'            }\n' +
'        }\n' +
'\n' +
'        function checkAnswers() {\n' +
'            let correct = 0;\n' +
'            let total = 0;\n' +
'            \n' +
'            currentGrid.forEach((row, r) => {\n' +
'                row.forEach((cell, c) => {\n' +
'                    if (!cell.isBlack) {\n' +
'                        total++;\n' +
'                        if (cell.letter && cell.letter === originalGrid[r][c].letter) {\n' +
'                            correct++;\n' +
'                        }\n' +
'                    }\n' +
'                });\n' +
'            });\n' +
'            \n' +
'            alert("You got " + correct + " out of " + total + " letters correct! (" + Math.round(correct/total*100) + "%)");\n' +
'        }\n' +
'\n' +
'        function revealAnswers() {\n' +
'            if (confirm("Are you sure you want to reveal all answers?")) {\n' +
'                currentGrid = originalGrid.map(row => row.map(cell => ({...cell})));\n' +
'                renderGrid();\n' +
'            }\n' +
'        }\n' +
'\n' +
'        function clearGrid() {\n' +
'            if (confirm("Are you sure you want to clear the grid?")) {\n' +
'                currentGrid.forEach(row => {\n' +
'                    row.forEach(cell => {\n' +
'                        if (!cell.isBlack) cell.letter = "";\n' +
'                    });\n' +
'                });\n' +
'                renderGrid();\n' +
'            }\n' +
'        }\n' +
'\n' +
'        function renderClues() {\n' +
'            const acrossDiv = document.getElementById("across-clues");\n' +
'            const downDiv = document.getElementById("down-clues");\n' +
'            \n' +
'            Object.entries(clues.across).forEach(([num, clue]) => {\n' +
'                const div = document.createElement("div");\n' +
'                div.className = "text-gray-700";\n' +
'                div.innerHTML = "<strong>" + num + ".</strong> " + clue;\n' +
'                acrossDiv.appendChild(div);\n' +
'            });\n' +
'            \n' +
'            Object.entries(clues.down).forEach(([num, clue]) => {\n' +
'                const div = document.createElement("div");\n' +
'                div.className = "text-gray-700";\n' +
'                div.innerHTML = "<strong>" + num + ".</strong> " + clue;\n' +
'                downDiv.appendChild(div);\n' +
'            });\n' +
'        }\n' +
'\n' +
'        renderGrid();\n' +
'        renderClues();\n' +
'    <\/script>\n' +
'</body>\n' +
'</html>';

            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'crossword-puzzle.html';
            a.click();
            URL.revokeObjectURL(url);
            
            alert('Shareable HTML puzzle downloaded! Anyone can open this file in their browser to solve your crossword.');
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-purple-50 to-blue-50 p-8">
              <div className="max-w-6xl mx-auto">
                <h1 className="text-4xl font-bold text-gray-800 mb-8 text-center">
                  Crossword Builder
                </h1>

                <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                  <div className="flex gap-4 mb-4 flex-wrap items-center">
                    <div className="flex gap-2 items-center">
                      <label className="font-medium text-gray-700">Rows:</label>
                      <input
                        type="number"
                        min="3"
                        max="20"
                        value={gridSize.rows}
                        onChange={(e) => {
                          const rows = parseInt(e.target.value) || 3;
                          setGridSize(prev => ({ ...prev, rows }));
                          setGrid(Array(rows).fill(null).map((_, i) => 
                            Array(gridSize.cols).fill(null).map((_, j) => 
                              grid[i]?.[j] || { letter: '', isBlack: false, number: null }
                            )
                          ));
                        }}
                        className="w-20 px-3 py-1 border border-gray-300 rounded"
                      />
                    </div>
                    <div className="flex gap-2 items-center">
                      <label className="font-medium text-gray-700">Cols:</label>
                      <input
                        type="number"
                        min="3"
                        max="20"
                        value={gridSize.cols}
                        onChange={(e) => {
                          const cols = parseInt(e.target.value) || 3;
                          setGridSize(prev => ({ ...prev, cols }));
                          setGrid(prev => prev.map(row => 
                            Array(cols).fill(null).map((_, j) => 
                              row[j] || { letter: '', isBlack: false, number: null }
                            )
                          ));
                        }}
                        className="w-20 px-3 py-1 border border-gray-300 rounded"
                      />
                    </div>
                    <button
                      onClick={autoNumberGrid}
                      className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition"
                    >
                      Auto-Number
                    </button>
                    <button
                      onClick={() => setShowClueEditor(!showClueEditor)}
                      className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition"
                    >
                      {showClueEditor ? 'Hide' : 'Show'} Clues
                    </button>
                    <button
                      onClick={() => setShowWordFinder(!showWordFinder)}
                      className="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 transition"
                    >
                      {showWordFinder ? 'Hide' : 'Show'} Word Finder
                    </button>
                    <button
                      onClick={exportCrossword}
                      className="px-4 py-2 bg-orange-600 text-white rounded hover:bg-orange-700 transition"
                    >
                      Export / Share
                    </button>
                  </div>

                  <div className="text-sm text-gray-600 mb-4">
                    Click a cell to select, type a letter, or press Space to toggle black cells. Use arrow keys to navigate.
                    <br />
                    <span className="font-semibold">Current direction: {direction === 'across' ? '→ Across' : '↓ Down'}</span> (Click selected cell again to toggle)
                  </div>

                  {/* Crossword Grid */}
                  <div className="inline-block border-4 border-gray-800 mb-6">
                    {grid.map((row, rowIndex) => (
                      <div key={rowIndex} className="flex">
                        {row.map((cell, colIndex) => {
                          const isSelected = selectedCell?.row === rowIndex && selectedCell?.col === colIndex;
                          const isInWord = selectedCell && (
                            (direction === 'across' && selectedCell.row === rowIndex && !cell.isBlack) ||
                            (direction === 'down' && selectedCell.col === colIndex && !cell.isBlack)
                          );
                          
                          return (
                            <div
                              key={colIndex}
                              data-cell={`${rowIndex}-${colIndex}`}
                              className={`w-12 h-12 border border-gray-400 relative cursor-pointer
                                ${cell.isBlack ? 'bg-gray-900' : 'bg-white'}
                                ${isSelected ? 'ring-2 ring-blue-600 ring-inset z-10' : ''}
                                ${isInWord && !isSelected ? 'bg-blue-100' : ''}`}
                              onClick={() => handleCellClick(rowIndex, colIndex)}
                              onKeyDown={(e) => handleCellKeyDown(e, rowIndex, colIndex)}
                              onDragOver={handleDragOver}
                              onDrop={(e) => handleDrop(e, rowIndex, colIndex)}
                              tabIndex={0}
                            >
                              {cell.number && !cell.isBlack && (
                                <span className="absolute top-0.5 left-0.5 text-xs font-bold text-gray-700">
                                  {cell.number}
                                </span>
                              )}
                              {!cell.isBlack && (
                                <div className="w-full h-full flex items-center justify-center text-2xl font-bold text-gray-800">
                                  {cell.letter}
                                </div>
                              )}
                            </div>
                          );
                        })}
                      </div>
                    ))}
                  </div>

                  {/* Alphabet Grid */}
                  <div className="bg-gray-50 p-4 rounded-lg">
                    <h3 className="font-semibold text-gray-700 mb-2">Drag letters to grid:</h3>
                    <div className="flex flex-wrap gap-2">
                      {alphabet.map(letter => (
                        <div
                          key={letter}
                          draggable
                          onDragStart={() => handleDragStart(letter)}
                          className="w-10 h-10 bg-blue-500 text-white flex items-center justify-center 
                                   font-bold rounded cursor-move hover:bg-blue-600 transition"
                        >
                          {letter}
                        </div>
                      ))}
                    </div>
                  </div>
                </div>

                {/* Word Finder */}
                {showWordFinder && (
                  <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <h2 className="text-2xl font-bold text-gray-800 mb-4">Word Finder</h2>
                    
                    <div className="mb-4">
                      <p className="text-sm text-gray-600 mb-3">
                        Enter a pattern using letters and ? for unknown positions (e.g., "C?T" finds CAT, COT, CUT, etc.)
                        <br />
                        Or select a cell and click "Find Across" or "Find Down" to auto-detect the pattern.
                      </p>
                      
                      <div className="flex gap-2 mb-3">
                        <button
                          onClick={() => findWordForCurrentCell('across')}
                          className="px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition text-sm"
                          disabled={!selectedCell}
                        >
                          Find Across
                        </button>
                        <button
                          onClick={() => findWordForCurrentCell('down')}
                          className="px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition text-sm"
                          disabled={!selectedCell}
                        >
                          Find Down
                        </button>
                      </div>
                      
                      <div className="flex gap-2">
                        <input
                          type="text"
                          value={wordPattern}
                          onChange={(e) => setWordPattern(e.target.value.toUpperCase())}
                          placeholder="Enter pattern (e.g., C?T)"
                          className="flex-1 px-4 py-2 border border-gray-300 rounded font-mono text-lg"
                          onKeyDown={(e) => e.key === 'Enter' && searchWords()}
                        />
                        <button
                          id="word-search-button"
                          onClick={searchWords}
                          disabled={isSearching}
                          className="px-6 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 transition disabled:bg-gray-400"
                        >
                          {isSearching ? 'Searching...' : 'Search'}
                        </button>
                      </div>
                    </div>

                    <div className="border-t pt-4">
                      {isSearching ? (
                        <div className="text-center py-8 text-gray-500">
                          <div className="animate-spin inline-block w-8 h-8 border-4 border-purple-600 border-t-transparent rounded-full mb-2"></div>
                          <p>Searching dictionary...</p>
                        </div>
                      ) : foundWords.length > 0 ? (
                        <div>
                          <h3 className="font-semibold text-gray-700 mb-3">
                            Found {foundWords.length} word{foundWords.length !== 1 ? 's' : ''}:
                          </h3>
                          <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2 max-h-96 overflow-y-auto">
                            {foundWords.map((word, idx) => (
                              <button
                                key={idx}
                                onClick={() => fillWordInGrid(word)}
                                className="px-3 py-2 bg-purple-50 hover:bg-purple-100 border border-purple-200 
                                         rounded font-mono text-sm transition text-left"
                                title="Click to insert into grid at selected position"
                              >
                                {word}
                              </button>
                            ))}
                          </div>
                          <p className="text-xs text-gray-500 mt-3">
                            Click any word to insert it at the selected cell position
                          </p>
                        </div>
                      ) : wordPattern ? (
                        <p className="text-center py-8 text-gray-500">
                          No words found matching "{wordPattern}". Try a different pattern.
                        </p>
                      ) : (
                        <p className="text-center py-8 text-gray-500">
                          Enter a pattern and click Search to find matching words
                        </p>
                      )}
                    </div>
                  </div>
                )}

                {/* Clue Editor */}
                {showClueEditor && (
                  <div className="bg-white rounded-lg shadow-lg p-6">
                    <h2 className="text-2xl font-bold text-gray-800 mb-4">Clues</h2>
                    
                    <div className="grid md:grid-cols-2 gap-6">
                      <div>
                        <h3 className="text-xl font-semibold text-gray-700 mb-3">Across</h3>
                        {clueNumbers.across.length === 0 ? (
                          <p className="text-gray-500 italic">No across clues yet. Add numbers first.</p>
                        ) : (
                          <div className="space-y-3">
                            {clueNumbers.across.map(num => (
                              <div key={num} className="flex gap-2 items-start">
                                <span className="font-bold text-gray-700 mt-2 min-w-[2rem]">{num}.</span>
                                <textarea
                                  value={clues.across[num] || ''}
                                  onChange={(e) => updateClue('across', num, e.target.value)}
                                  placeholder="Enter clue..."
                                  className="flex-1 px-3 py-2 border border-gray-300 rounded resize-none"
                                  rows="2"
                                />
                              </div>
                            ))}
                          </div>
                        )}
                      </div>

                      <div>
                        <h3 className="text-xl font-semibold text-gray-700 mb-3">Down</h3>
                        {clueNumbers.down.length === 0 ? (
                          <p className="text-gray-500 italic">No down clues yet. Add numbers first.</p>
                        ) : (
                          <div className="space-y-3">
                            {clueNumbers.down.map(num => (
                              <div key={num} className="flex gap-2 items-start">
                                <span className="font-bold text-gray-700 mt-2 min-w-[2rem]">{num}.</span>
                                <textarea
                                  value={clues.down[num] || ''}
                                  onChange={(e) => updateClue('down', num, e.target.value)}
                                  placeholder="Enter clue..."
                                  className="flex-1 px-3 py-2 border border-gray-300 rounded resize-none"
                                  rows="2"
                                />
                              </div>
                            ))}
                          </div>
                        )}
                      </div>
                    </div>
                  </div>
                )}

                {/* Export/Import Modal */}
                {showExportModal && (
                  <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
                    <div className="bg-white rounded-lg shadow-xl max-w-4xl w-full max-h-[90vh] overflow-y-auto p-6">
                      <div className="flex justify-between items-center mb-4">
                        <h2 className="text-2xl font-bold text-gray-800">Export & Share Crossword</h2>
                        <button
                          onClick={() => setShowExportModal(false)}
                          className="text-gray-500 hover:text-gray-700 text-2xl"
                        >
                          ×
                        </button>
                      </div>

                      <div className="space-y-4">
                        <div className="border-b pb-4">
                          <h3 className="text-lg font-semibold text-gray-700 mb-3">Share as Playable Puzzle</h3>
                          <p className="text-sm text-gray-600 mb-3">
                            Generate a standalone HTML file that others can open in their browser to solve your crossword.
                            They won't see the answers until they check or reveal them.
                          </p>
                          <button
                            onClick={generateSharableHTML}
                            className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition"
                          >
                            Download Playable Puzzle (HTML)
                          </button>
                        </div>

                        <div className="border-b pb-4">
                          <h3 className="text-lg font-semibold text-gray-700 mb-3">Export for Editing</h3>
                          <p className="text-sm text-gray-600 mb-3">
                            Save your crossword design as JSON to continue editing later or share with other builders.
                          </p>
                          <div className="flex gap-2">
                            <button
                              onClick={downloadCrossword}
                              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition"
                            >
                              Download JSON
                            </button>
                            <button
                              onClick={copyToClipboard}
                              className="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 transition"
                            >
                              Copy to Clipboard
                            </button>
                          </div>
                          {exportedData && (
                            <div className="mt-3">
                              <textarea
                                value={exportedData}
                                readOnly
                                className="w-full h-32 p-2 border border-gray-300 rounded font-mono text-xs"
                              />
                            </div>
                          )}
                        </div>

                        <div>
                          <h3 className="text-lg font-semibold text-gray-700 mb-3">Import Crossword</h3>
                          <p className="text-sm text-gray-600 mb-3">
                            Paste crossword JSON data to load a saved design.
                          </p>
                          <textarea
                            value={importData}
                            onChange={(e) => setImportData(e.target.value)}
                            placeholder="Paste JSON data here..."
                            className="w-full h-32 p-2 border border-gray-300 rounded font-mono text-xs mb-2"
                          />
                          <button
                            onClick={importCrossword}
                            className="px-4 py-2 bg-orange-600 text-white rounded hover:bg-orange-700 transition"
                          >
                            Import Crossword
                          </button>
                        </div>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>
          );
        }

        ReactDOM.render(<CrosswordBuilder />, document.getElementById('root'));
    </script>
</body>
</html>
